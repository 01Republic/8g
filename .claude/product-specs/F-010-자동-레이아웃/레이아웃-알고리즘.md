# 자동 레이아웃 - 알고리즘

**상위 문서**: [F-010: 자동 레이아웃](../F-010-자동-레이아웃.md)
**최종 수정일**: 2025-11-11

---

## 개요

이 문서는 워크플로우 자동 레이아웃의 핵심 알고리즘인 Dagre와 구현 상세를 다룹니다.

---

## Dagre 알고리즘

### 개요

**Dagre**: 방향 그래프(Directed Graph) 레이아웃 라이브러리

**특징**:
- 계층적(Hierarchical) 배치
- 엣지 교차 최소화
- 노드 간격 자동 계산
- 여러 레이아웃 방향 지원 (TB, LR, RL, BT)

**공식 사이트**: https://github.com/dagrejs/dagre

### 작동 원리

1. **그래프 생성**: 노드와 엣지를 Dagre 그래프로 변환
2. **레이아웃 계산**: Sugiyama 알고리즘으로 최적 위치 계산
3. **위치 매핑**: 계산된 좌표를 React Flow 노드에 적용

---

## autoLayout 함수

**파일**: `app/client/admin/workflowBuilder/utils/autoLayout.ts`

### 기본 구현

```typescript
import dagre from "dagre";
import { Node, Edge } from "@xyflow/react";

export interface LayoutOptions {
  direction?: "TB" | "LR" | "RL" | "BT";
  nodeWidth?: number;
  nodeHeight?: number;
  rankSep?: number;    // 레벨 간 간격
  nodeSep?: number;    // 노드 간 간격
}

export function applyDagreLayout(
  nodes: Node[],
  edges: Edge[],
  options: LayoutOptions = {}
): Node[] {
  const {
    direction = "TB",
    nodeWidth = 250,
    nodeHeight = 100,
    rankSep = 100,
    nodeSep = 50
  } = options;

  // 1. Dagre 그래프 생성
  const g = new dagre.graphlib.Graph();
  g.setGraph({
    rankdir: direction,
    ranksep: rankSep,
    nodesep: nodeSep
  });
  g.setDefaultEdgeLabel(() => ({}));

  // 2. 노드 추가
  nodes.forEach((node) => {
    g.setNode(node.id, {
      width: nodeWidth,
      height: nodeHeight
    });
  });

  // 3. 엣지 추가
  edges.forEach((edge) => {
    g.setEdge(edge.source, edge.target);
  });

  // 4. 레이아웃 계산
  dagre.layout(g);

  // 5. 노드 위치 업데이트
  const layoutedNodes = nodes.map((node) => {
    const nodeWithPosition = g.node(node.id);
    return {
      ...node,
      position: {
        x: nodeWithPosition.x - nodeWidth / 2,
        y: nodeWithPosition.y - nodeHeight / 2
      }
    };
  });

  return layoutedNodes;
}
```

### 주요 파라미터

| 파라미터 | 설명 | 기본값 |
|---------|------|--------|
| `direction` | 레이아웃 방향 (TB/LR/RL/BT) | TB |
| `nodeWidth` | 노드 너비 | 250 |
| `nodeHeight` | 노드 높이 | 100 |
| `rankSep` | 레벨 간 간격 | 100 |
| `nodeSep` | 동일 레벨 노드 간격 | 50 |

---

## 동적 노드 크기 계산

노드 타입에 따라 크기를 동적으로 조정합니다.

```typescript
function getNodeDimensions(node: Node): { width: number; height: number } {
  switch (node.type) {
    case "start":
    case "end":
      return { width: 150, height: 50 };

    case "block":
      // 블록 타입에 따라 크기 조정
      const hasRepeat = !!node.data.repeat;
      const hasSwitch = !!node.data.switch;

      return {
        width: 250,
        height: hasRepeat || hasSwitch ? 120 : 100
      };

    default:
      return { width: 200, height: 80 };
  }
}

export function applyDagreLayoutDynamic(
  nodes: Node[],
  edges: Edge[]
): Node[] {
  const g = new dagre.graphlib.Graph();
  g.setGraph({ rankdir: "TB" });
  g.setDefaultEdgeLabel(() => ({}));

  // 노드별 동적 크기 적용
  nodes.forEach((node) => {
    const { width, height } = getNodeDimensions(node);
    g.setNode(node.id, { width, height });
  });

  edges.forEach((edge) => {
    g.setEdge(edge.source, edge.target);
  });

  dagre.layout(g);

  return nodes.map((node) => {
    const nodeWithPosition = g.node(node.id);
    const { width, height } = getNodeDimensions(node);

    return {
      ...node,
      position: {
        x: nodeWithPosition.x - width / 2,
        y: nodeWithPosition.y - height / 2
      }
    };
  });
}
```

---

## 사용 방법

### 1. 워크플로우 로드 시 자동 레이아웃

```typescript
// app/routes/workflow-builder.tsx
export async function loader({ params }: LoaderFunctionArgs) {
  const workflowId = params.workflowId;

  if (!workflowId) {
    return json({ workflow: null, nodes: [], edges: [] });
  }

  const workflow = await findWorkflowMetadata(Number(workflowId));

  if (!workflow) {
    throw new Response("Workflow not found", { status: 404 });
  }

  // 워크플로우 → 노드/엣지 변환
  const { nodes, edges } = convertWorkflowToNodesAndEdges(workflow.meta);

  // 자동 레이아웃 적용
  const layoutedNodes = applyDagreLayout(nodes, edges);

  return json({
    workflow,
    nodes: layoutedNodes,
    edges
  });
}
```

### 2. 수동 레이아웃 버튼

```typescript
// WorkflowBuilderHeader.tsx
function WorkflowBuilderHeader() {
  const [nodes, setNodes] = useNodesState([]);
  const [edges, setEdges] = useEdgesState([]);

  const handleAutoLayout = () => {
    const layoutedNodes = applyDagreLayout(nodes, edges);
    setNodes(layoutedNodes);
  };

  return (
    <div className="flex gap-2">
      <Button
        variant="outline"
        onClick={handleAutoLayout}
      >
        <LayoutGrid className="w-4 h-4 mr-2" />
        Auto Layout
      </Button>
    </div>
  );
}
```

---

## 레이아웃 애니메이션

```typescript
// 레이아웃 변경 시 CSS 트랜지션 적용
function handleAutoLayoutWithAnimation() {
  const layoutedNodes = applyDagreLayout(nodes, edges);

  // 애니메이션 적용
  setNodes((prevNodes) =>
    prevNodes.map((node, index) => ({
      ...node,
      position: layoutedNodes[index].position,
      style: {
        transition: "all 0.3s ease-in-out"
      }
    }))
  );
}
```

---

## 관련 문서

- [F-010: 자동 레이아웃](../F-010-자동-레이아웃.md) - 메인 문서
- [레이아웃 전략](./레이아웃-전략.md) - 레이아웃 패턴 및 최적화

---

**문서화 원칙 준수**:
- ✅ 200줄 이하
- ✅ 한글 작성
- ✅ 알고리즘 구현 중심
