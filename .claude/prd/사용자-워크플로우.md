# 사용자 워크플로우

**문서 버전**: 1.0
**최종 수정일**: 2025-11-11
**상위 문서**: [PRD](../PRD.md)

---

## 개요

이 문서는 8G 플랫폼의 주요 사용자 시나리오와 워크플로우를 상세히 설명합니다. 실제 사용 사례를 기반으로 사용자 여정(User Journey)과 시스템 상호작용을 정의합니다.

---

## 주요 사용자 페르소나

### 페르소나 1: 데이터 분석가

**배경**:

- 이름: 김데이터
- 역할: 마케팅 데이터 분석가
- 기술 수준: 중급 (SQL 가능, 프로그래밍 경험 없음)
- 목표: 경쟁사 가격 데이터 자동 수집

**니즈**:

- 매일 아침 경쟁사 웹사이트에서 가격 정보 수집
- Excel/CSV 형태로 데이터 내보내기
- 비개발자도 쉽게 사용할 수 있는 도구

### 페르소나 2: 백오피스 담당자

**배경**:

- 이름: 박백오
- 역할: 운영팀 백오피스 담당자
- 기술 수준: 초급 (Excel 능숙)
- 목표: 반복적인 데이터 입력 작업 자동화

**니즈**:

- 여러 시스템 간 데이터 전송 자동화
- 로그인 → 데이터 추출 → API 전송 프로세스 자동화
- 실행 스케줄링 (향후 기능)

### 페르소나 3: 개발자

**배경**:

- 이름: 이개발
- 역할: 풀스택 개발자
- 기술 수준: 고급 (JavaScript, Python)
- 목표: QA 테스트 자동화, 복잡한 데이터 파이프라인 구축

**니즈**:

- 복잡한 조건부 로직 구현
- API 통합 및 데이터 변환
- JSONata 표현식 활용한 고급 데이터 처리

---

## 핵심 사용자 워크플로우

### 워크플로우 1: 웹사이트 데이터 추출

**시나리오**: 경쟁사 제품 가격 수집

**사용자 여정**:

```
1. 워크플로우 생성
   사용자 액션: "New Workflow" 버튼 클릭
   시스템 응답: 빈 캔버스 표시

2. 타겟 URL 설정
   사용자 액션: Target URL 입력 "https://competitor.com/products"
   시스템 응답: URL 유효성 검증

3. 블록 추가
   사용자 액션: "get-element-data" 블록을 캔버스에 드래그
   시스템 응답: 블록 노드 생성, 설정 모달 표시

4. 블록 설정
   사용자 액션:
     - selector: ".product-item"
     - multiple: true
     - fields 설정:
       - name: { selector: ".product-name" }
       - price: { selector: ".product-price" }
   시스템 응답: 블록 설정 저장

5. 저장 및 실행
   사용자 액션: "Save" → "Run Workflow"
   시스템 응답:
     - 워크플로우 JSON 생성
     - Extension 통해 브라우저 탭 열기
     - 데이터 추출 실행
     - 결과 ResultPanel에 표시

6. 결과 확인 및 Export
   사용자 액션: "Export to CSV" 클릭
   시스템 응답: CSV 파일 다운로드
```

**예상 소요 시간**: 5-10분 (처음 사용자)

**성공 기준**:

- ✅ 원하는 데이터 필드 추출 성공
- ✅ 데이터 형식이 올바름 (가격 → 숫자)
- ✅ CSV 파일 정상 다운로드

---

### 워크플로우 2: 로그인 후 데이터 수집

**시나리오**: 로그인이 필요한 사이트에서 데이터 추출

**사용자 여정**:

```
1. 워크플로우 생성 및 URL 설정
   Target URL: "https://app.example.com/login"

2. 로그인 스텝 추가
   Step 1 (login_email):
     Block: keypress
     selector: "#email"
     value: "${vars.email}"

   Step 2 (login_password):
     Block: keypress
     selector: "#password"
     value: "${vars.password}"

   Step 3 (click_login):
     Block: event-click
     selector: "button[type=submit]"
     delayAfterMs: 2000

3. 로그인 확인 스텝
   Step 4 (check_dashboard):
     Block: element-exists
     selector: ".dashboard"

   조건 분기 추가:
     IF exists → extract_data
     ELSE → login_failed

4. 데이터 추출 스텝
   Step 5 (extract_data):
     Block: get-element-data
     selector: ".data-row"
     multiple: true

5. 변수 설정
   사용자 액션: Variables Dialog 열기
   입력:
     - email: "user@example.com"
     - password: "****"

6. 실행
   사용자 액션: "Run Workflow"
   시스템 응답:
     - 변수 치환 처리
     - Extension으로 워크플로우 전송
     - 로그인 자동 수행
     - 데이터 추출
     - 결과 표시
```

**예상 소요 시간**: 15-20분 (처음 사용자)

**성공 기준**:

- ✅ 자동 로그인 성공
- ✅ 로그인 실패 시 에러 핸들링
- ✅ 대시보드 데이터 정상 추출

---

### 워크플로우 3: API 통합 워크플로우

**시나리오**: 웹사이트 데이터를 추출하여 내부 API로 전송

**사용자 여정**:

```
1. 데이터 추출 블록 추가
   Step 1 (extract_products):
     Block: get-element-data
     selector: ".product"
     multiple: true

2. 데이터 변환 블록 추가
   Step 2 (transform_data):
     Block: transform-data
     sourceData: "$.steps.extract_products.result.data"
     expression: "*.{ productId: id, productName: name, price: $number(price) }"

3. API 호출 블록 추가
   Step 3 (send_to_api):
     Block: fetch-api
     url: "https://internal-api.com/products"
     method: "POST"
     headers:
       Authorization: "Bearer ${vars.apiKey}"
     body: "$.steps.transform_data.result.data"

4. 응답 확인 블록
   Step 4 (check_response):
     Block: get-text (이전 API 응답 확인용)

   조건 분기:
     IF status == "success" → success_notification
     ELSE → retry_api_call

5. 변수 설정
   apiKey: "abc123..."

6. 실행 및 모니터링
   사용자 액션: "Run Workflow"
   시스템 응답:
     - 각 스텝 순차 실행
     - API 응답 로깅
     - 최종 결과 표시
```

**예상 소요 시간**: 25-30분

**성공 기준**:

- ✅ 데이터 추출 성공
- ✅ JSONata 변환 정확성
- ✅ API 호출 성공 (200 OK)
- ✅ 에러 발생 시 재시도 로직 동작

---

### 워크플로우 4: 루프를 활용한 페이지네이션

**시나리오**: 여러 페이지의 데이터 일괄 수집

**사용자 여정**:

```
1. 페이지 목록 추출
   Step 1 (get_page_links):
     Block: get-element-data
     selector: ".pagination a"
     multiple: true
     fields:
       url: { selector: "a", attribute: "href" }

2. 각 페이지 방문 루프
   Step 2 (visit_page):
     Block: navigate
     url: "${$.forEach.item.url}"
     repeat:
       forEach: "$.steps.get_page_links.result.data"

3. 페이지별 데이터 추출
   Step 3 (extract_page_data):
     Block: get-element-data
     selector: ".item"
     multiple: true

4. 결과 병합
   Step 4 (merge_results):
     Block: transform-data
     sourceData: "$.steps.extract_page_data.result.data"
     expression: "$"  # 모든 결과 병합
```

**예상 소요 시간**: 20-25분

**성공 기준**:

- ✅ 모든 페이지 방문 완료
- ✅ 각 페이지 데이터 정상 추출
- ✅ 중복 데이터 제거

---

## 에러 시나리오 및 대응

### 에러 시나리오 1: Extension 미설치

**상황**: 사용자가 "Run Workflow" 클릭 시 Extension 미설치

**시스템 응답**:

```
Alert: "8G Extension이 설치되지 않았습니다."
안내 메시지: Extension 설치 링크 제공
```

**사용자 액션**: Extension 설치 후 재시도

### 에러 시나리오 2: Selector 오류

**상황**: CSS Selector가 요소를 찾지 못함

**시스템 응답**:

```
Error in Step "extract_data": Element not found
ResultPanel에 에러 메시지 표시
```

**사용자 액션**:

- Selector 수정
- 페이지 로딩 대기 시간 추가 (delayAfterMs)

### 에러 시나리오 3: API 타임아웃

**상황**: API 호출 시 응답 지연

**시스템 응답**:

```
Retry attempt 1/3...
Retry attempt 2/3...
Error: Request timeout after 3 attempts
```

**사용자 액션**:

- timeoutMs 증가
- retry 설정 조정

---

## 사용자 피드백 루프

### 워크플로우 개선 사이클

```
1. 초기 워크플로우 생성
   ↓
2. 테스트 실행
   ↓
3. 결과 확인 및 에러 파악
   ↓
4. 블록 설정 수정
   ↓
5. 재실행
   ↓
6. 만족할 때까지 반복
   ↓
7. 워크플로우 저장 및 재사용
```

### 일반적인 개선 포인트

- Selector 정확도 향상
- 페이지 로딩 대기 시간 조정
- 조건 분기 추가로 에러 핸들링 강화
- 변수 활용으로 재사용성 증대

---

## 관련 문서

- [PRD](../PRD.md)
- [F-001: 워크플로우 빌더](../product-specs/F-001-워크플로우-빌더.md)
- [F-007: 워크플로우 실행](../product-specs/F-007-워크플로우-실행.md)

---

**변경 이력**

| 버전 | 날짜       | 변경 내용 | 작성자 |
| ---- | ---------- | --------- | ------ |
| 1.0  | 2025-11-11 | 최초 작성 | System |
